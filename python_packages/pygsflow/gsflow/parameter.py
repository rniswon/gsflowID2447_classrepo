from __future__ import (absolute_import, division, print_function)
import os
import numpy as np
import logging
import copy


class Parameters(object):
    """
    Class to hold parameters information.

    """

    def __init__(self, parameters_list=None, parameter_files=['temp_parm.parm']):
        """

        :param parameters_list: list that holds param_record objects
        :param parameter_files: list holds strings for parameter files names
                            The first file is the main one
        """
        # default header
        self.headers = ["Parameter files generated by gsflow python package"]
        if not (parameters_list == None):
            self._parameter_files = parameter_files
            self.parameters_list = parameters_list

        elif os.path.isfile(parameter_files[0]):
            self._parameter_files = parameter_files
            print("Work on loadind the parameter files .....")
            self.from_file()
        else:
            print ("Cannot find the file {}".format(parameter_files[0]))
            raise ValueError(" Cannot find the file {}".format(parameter_files[0]))


        self._record_names = []
        if not (self.parameters_list == None):
            for rec in self.parameters_list:
                self._record_names.append(rec.name)

    #TODO : this need to be written
    @property
    def parameter_files(self):

        all_files = []

        for rec in self.parameters_list:
            if rec.section == 'Dimensions':
                if rec.file_name in all_files:
                    continue
                else:
                    all_files.insert(0, rec.file_name)
            else:
                if not (rec.file_name in all_files):
                    all_files.append(rec.file_name)

        self._parameter_files = all_files
        return self._parameter_files
        pass




        return self._parameter_files


    def from_file(self, filename=None):
        # todo: msg
        if filename:
            pfiles = filename
        else:
            pfiles = self._parameter_files

        # loop over parameter files and load them successively
        all_dims = {}
        headers = []
        parameters_list = []
        for ifile, file in enumerate(pfiles):
            if not (os.path.isfile(file)):
                raise ValueError("Invalid file name ....")

            fid = open(file, 'r')
            content = fid.readlines()
            fid.close()
            content = content.__iter__()


            EndOfFile = False
            _read_comments = True
            in_dim_section = False

            while True:

                try:
                    record = content.next().strip()
                except:
                    break
                if record == '':
                    continue

                # read comments
                if _read_comments:
                    if "####" in record or ('** Dimensions **' in record) or ('** Parameters **' in record):
                        _read_comments = False
                    else:
                        headers.append([record, file])
                        continue

                ## read records information Not comments

                if ('** Parameters **' in record):
                    in_dim_section = False

                    continue
                    # record = content.next().strip()
                    # if not ( record == "####"):
                    #     raise ValueError("Error reading Parameters Section...")
                    # continue

                elif '** Dimensions **' in record:
                    in_dim_section = True
                    continue
                    # record = content.next().strip()
                    # if not (record == "####"):
                    #     raise ValueError("Error reading Dimensions Section...")

                if '####' in record:
                    continue

                if in_dim_section:
                    # Reading Dimensions Section
                    field_name = record.strip()
                    value = int(content.next().strip())
                    curr_record = Parm_record(name=field_name, values=[value], file_name=file)
                    parameters_list.append(curr_record)
                    all_dims[field_name] = value


                else:
                    # read Parameters section
                    field_name = record.strip().split()[0]

                    try:
                        ndim = int(content.next().strip())
                    except:
                        pass
                    dim_nms = []
                    for dim_ in range(ndim):
                        dim_nms.append((content.next().strip()))
                    try:
                        nvalues = int(content.next().strip())
                    except:
                        pass
                    datatype = int(content.next().strip())
                    value = []
                    # read values sequentially
                    val_count = 0
                    while val_count < nvalues:
                        val_ = content.next().strip()
                        if '*' in val_:
                            comp_val = val_.split('*')
                            value = value + [comp_val[1]] * int(comp_val[0])
                            val_count = val_count + int(comp_val[0])

                        else:
                            value.append(val_)
                            val_count = val_count + 1

                    par_dim = []
                    for dn in dim_nms:
                        par_dim.append([dn, all_dims[dn]])
                    curr_record = Parm_record(name=field_name, values=value, dimensions=par_dim,
                                              datatype=datatype, file_name=file)

                    parameters_list.append(curr_record)

            self.headers = headers
            self.parameters_list = parameters_list

    def get_record(self, name):
        """
        Get a complete record object
        :return:
        """
        record = None
        if len(self.parameters_list) > 0:
            for rec in self.parameters_list:
                if rec.name == name:
                    record = rec
                    break
        else:
            print("Parameter Object is empty....")
            return None

        if isinstance(record, Parm_record):
            return record
        else:
            print("The record does not exist...")
            return None

    def get_values(self, name):
        """
                Get a complete record object
                :return:
                """
        values = None
        if len(self.parameters_list) > 0:
            for rec in self.parameters_list:
                if rec.name == name:
                    values = rec.values
                    break
        else:
            print("Parameter Object is empty....")
            return None

        if isinstance(values, np.ndarray):
            return values
        else:
            print("The values does not exist...")
            return None

    def set_values(self, name, values):
        """
                Get a complete record object
                :return:
                """

        if len(self.parameters_list) > 0:
            for rec in self.parameters_list:
                if rec.name == name:
                    rec.values = values
                    break
        else:
            print("Control Object is empty....")
            return None

        if isinstance(values, np.ndarray):
            return values
        else:
            print("The record does not exist...")
            return None

    def get_record_names(self):
        return self._record_names

    def add_record(self, name=None, values=None, dimensions=None,
                   datatype=None, width=10, file_name=None, where=None, after=None):

        if isinstance(name, str):
            pass
        else:
            raise ValueError("Record name must be string")
        if isinstance(values, list) or isinstance(values, np.ndarray):
            pass
        else:
            raise ValueError("Record name must be string")

        if name in self._record_names:
            print("The record already exist...")
            return
        new_record = Parm_record(name=name, values=values, dimensions=dimensions, datatype=datatype)

        if after:
            for index, recc in enumerate(self._record_names):
                if recc == after:
                    break;
            self._record_names.insert(index + 1, name)
            self.parameters_list.insert(index + 1, new_record)
            return

        if where:
            self._record_names.insert(where, name)
            self.parameters_list.insert(where, new_record)
        else:
            self._record_names = self._record_names + [name]
            self.parameters_list = self.parameters_list + [new_record]

    def remove_record(self, name):
        if isinstance(name, str):
            pass
        else:
            raise ValueError("Record name must be string")

        if name not in self._record_names:
            print("The record does not exist...")
            return

        for index, nm in enumerate(self._record_names):
            if nm == name:
                del self._record_names[index]
                del self.parameters_list[index]
                return

    def write(self):
        file_list = self.parameter_files
        for ifile, filename in enumerate(file_list):
            fid = open(filename, 'w')
            if ifile==0:
                txt = "Generated by Gsflow python Package....\n"
                txt = txt + "Version : --.--"
                fid.write(txt)
                fid.write("\n** Dimensions **")
            # write dimension
            for record in self.parameters_list:
                # write dimension first
                if ifile == 0 and record.section == 'Dimensions':
                    if os.path.normpath(record.file_name) == os.path.normpath(filename):
                        record.write(fid)
            ##
            # write param
            if (ifile == 0):
                fid.write("\n")
                fid.write("** Parameters **")
            for record in self.parameters_list:
                # write dimension first
                if not(record.section == 'Dimensions'):
                    if os.path.normpath(record.file_name) == os.path.normpath(filename):
                        record.write(fid)

            fid.write("\n")
            fid.close()
            pass


class Parm_record(object):
    def __init__(self, name=None, values=None, dimensions=None,
                 datatype=None, width=10, file_name=None):
        """

        :param name: string for field name
        :param values: list or numpy array
        :param datatype:
        :param nvalues:
        :param width is ignored by gsflow
        integer no_diemsnions : dimension names also will be used to predict if the parameter is Dimensions or
        Parameters

        """

        self.DATA_TYPES_options = {1: 'integer', 2: 'real', 3: 'double', '4': 'string'}
        self.SECTIONS_options = ['Dimensions', 'Parameters']
        self.file_name = file_name
        self._dimensions = dimensions
        if self._dimensions:
            self.dimensions_names = [nm[0] for nm in dimensions]
            self.dims = [nm[1] for nm in dimensions]
        self.width = width
        # record name
        if isinstance(name, str):
            self.name = name
        else:
            raise ValueError("Error: Name of the record ( {} ) is not a string".format(name))

        # record values
        self._check_values(values)

        # the parameter belong to dimension sections or parameters section?
        if self._dimensions == None:  #
            if len(self._values) > 1:
                raise ValueError("Error : Values in the Dimension section must be scalar... ")
            self.dimensions_names = None
            self.dims = None
            self.datatype = 1  # always integer
            self.ndim = 1
            self.section = 'Dimensions'

        else:  # the record belongs to parameters section
            self.ndim = len(self.dimensions_names)
            if self.ndim < 1:
                raise ValueError("No dimension names are specified")

            # Todo: infer data dimension from data
            if self._values.ndim > 1:
                pass
            else:
                pass
            self.section = 'Parameters'

            # number of values
            _nvalues = np.prod(np.array(self.dims))
            if _nvalues != self._values.size:
                raise ValueError("Summation of values in all dimensions is not equal to number of values")
            self._nvalues = _nvalues

            # data type
            if datatype:
                self.datatype = datatype
                self._force_dtype()
            else:
                print("Warning: data type will be infered from data supplied")
                if 'float' in self.values.dtype.name:
                    self.datatype = 2
                elif 'int' in self.values.dtype.name:
                    self.datatype = 1
                elif 'string' in self.values.dtype.name:
                    self.datatype = 4
                else:
                    raise ValueError("Value type is not recognized...{}", self.values.dtype)

    def _check_values(self, new_values):
        if isinstance(new_values, np.ndarray):
            self._values = new_values
        elif isinstance(new_values, list):
            try:
                new_values = np.array(new_values)
                self._values = new_values
            except:
                raise ValueError("Cannot convert the list to 1D numpy array ")
        else:
            raise ValueError("Values must be list or 1D numpy array ")

    @property
    def values(self):
        return self._values

    @values.setter
    def values(self, new_values):
        self._check_values(new_values)
        if np.prod(np.array(self.dims)) != self._values.size:
            raise ValueError(" The number of values is not compatible with the dimensions")

        # change data type
        self._check_dtype()

    @property
    def nvalues(self):
        return self._nvalues

    @nvalues.setter
    def nvalues(self, values):
        print("Warninig : You cannot change nvalues, becuase it is calculated internally")
        # do no thing

    def _check_dtype(self):
        if 'float' in self.values.dtype.name:
            self.datatype = 2
        elif 'int' in self.values.dtype.name:
            self.datatype = 1
        elif 'string' in self.values.dtype.name:
            self.datatype = 4
        else:
            raise ValueError("Value type is not recognized...{}", self.values.dtype)

    def _force_dtype(self):
        # {1: 'integer', 2: 'real', 3: 'double', '4': 'string'}
        type = self.DATA_TYPES_options[self.datatype]
        if type == 'integer':
            self.values = self.values.astype(int)
        elif type == 'real' or type == 'double':
            self.values = self.values.astype(float)

        elif type == 'string':
            self.values = self.values.astype(str)
        else:
            raise ValueError("Error : Cannot recognize data type")

    def _write_dimension(self, fid):
        fid.write("\n")
        fid.write("####")
        fid.write("\n")
        fid.write(self.name)
        # write values
        for val in self.values:
            fid.write("\n")
            fid.write(str(val))
        pass
    def _write_parameter(self, fid):
        fid.write("\n")
        fid.write("####")
        fid.write("\n")
        fid.write(self.name)
        fid.write(" ")
        fid.write(str(self.width))
        # write number of dimension
        fid.write("\n")
        fid.write(str(self.ndim))

        # write dimension names

        for nm in self.dimensions_names:
            fid.write("\n")
            fid.write(nm)

        # write nvalues
        fid.write("\n")
        fid.write(str(self.nvalues))

        # write datatype
        fid.write("\n")
        fid.write(str(self.datatype))

        # write values
        for val in self.values:
            fid.write("\n")
            fid.write(str(val))

    def write(self, fid):

        if self.section == "Dimensions":
            self._write_dimension(fid)
        else:
            self._write_parameter(fid)






    def __repr__(self):
        try:
            return self.name
        except:
            return "Param. Record"

    def __str__(self):
        if self._dimensions == None:  # print record for dimension
            print_str = ""
            print_str = print_str + "\n"
            print_str = print_str + "####"
            print_str = print_str + "\n"
            print_str = print_str + self.name
            print_str = print_str + "\n"
            print_str = print_str + str(self.values[0])
            print_str = print_str + "\n"
            print_str = print_str + "####"
            return print_str
        else:  # print regular param.
            print_str = ""
            print_str = print_str + "\n"
            print_str = print_str + "####"
            print_str = print_str + "\n"
            print_str = print_str + self.name + " " + str(self.width)
            print_str = print_str + "\n"
            print_str = print_str + str(self.ndim)
            print_str = print_str + "\n"
            for dim_nam in self.dimensions_names:
                print_str = print_str + dim_nam
                print_str = print_str + "\n"
            print_str = print_str + str(self.nvalues)
            print_str = print_str + "\n"
            print_str = print_str + str(self.datatype)

            # write values
            for i, val in enumerate(self.values):
                if i > 3:
                    print_str = print_str + ".\n.\n."
                    break
                print_str = print_str + "\n"
                print_str = print_str + str(val)

            print_str = print_str + "\n"
            print_str = print_str + "####"
            return print_str

    def from_dict(self):
        pass

    def to_dict(self):
        pass
